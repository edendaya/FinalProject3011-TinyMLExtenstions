*4196 instructions are running
*4x4 matrix-vector multiplication for neural network inference (one row shown) on simple dlx.
beqz R0 20
* --- Data section: 4x4 matrix ---
data1: dc 0x00000001
data2: dc 0x00000002
data3: dc 0x00000003
data4: dc 0x00000004
data5: dc 0x00000005
data6: dc 0x00000006
data7: dc 0x00000007
data8: dc 0x00000008
data9: dc 0x00000009
data10: dc 0x0000000A
data11: dc 0x0000000B
data12: dc 0x0000000C
data13: dc 0x0000000D
data14: dc 0x0000000E
data15: dc 0x0000000F
data16: dc 0x00000010
data17: dc 0x00000011
data18: dc 0x00000012
data19: dc 0x00000013
data20: dc 0x00000014

* --- Output addresses ---
addr1: ds
addr2: ds
addr3: ds
addr4: ds

* --- Row 0 computation ---
addi R7 R0 0   * Result storage
addi R8 R0 0   * Temp storage
addi R9 R0 1   * Mask for AND operation
addi R10 R0 0  * Loop counter
addi R11 R0 15 * Iteration count for shifts

lw R1 R0 data1
lw R2 R0 data2
lw R3 R0 data3
lw R4 R0 data4
lw R5 R0 vdata1
lw R6 R0 vdata2
lw R7 R0 vdata3
lw R8 R0 vdata4

* Multiplication 1: R1 * R5
addi R16 R0 8000
and R13 R1 R16
and R14 R5 R16
xor R15 R13 R14
beqz R13 1
sub R1 R0 R1
beqz R14 1
sub R5 R0 R5
*mul1_loop:
and R12 R9 R5
beqz R12 2
add R9 R9 R1
addi R10 R10 1
*sll1:
slli R1 R1
srli R5 R5
addi R11 R11 -1
bnez R11 -8
beqz R15 1
sub R9 R0 R9

* Multiplication 2: R2 * R6
addi R16 R0 8000
and R13 R2 R16
and R14 R6 R16
xor R15 R13 R14
beqz R13 1
sub R2 R0 R2
beqz R14 1
sub R6 R0 R6
*mul2_loop:
and R12 R9 R6
beqz R12 2
add R8 R8 R2
addi R10 R10 1
*sll2:
slli R2 R2
srli R6 R6
addi R11 R11 -1
bnez R11 -8
beqz R15 1
sub R8 R0 R8

* Multiplication 3: R3 * R7
addi R16 R0 8000
and R13 R3 R16
and R14 R7 R16
xor R15 R13 R14
beqz R13 1
sub R3 R0 R3
beqz R14 1
sub R7 R0 R7
*mul3_loop:
and R12 R9 R7
beqz R12 2
add R9 R9 R3
addi R10 R10 1
*sll3:
slli R3 R3
srli R7 R7
addi R11 R11 -1
bnez R11 -8
beqz R15 1
sub R9 R0 R9

* Multiplication 4: R4 * R8
addi R16 R0 8000
and R13 R4 R16
and R14 R8 R16
xor R15 R13 R14
beqz R13 1
sub R4 R0 R4
beqz R14 1
sub R8 R0 R8
*mul4_loop:
and R12 R9 R8
beqz R12 2
add R8 R8 R4
addi R10 R10 1
*sll4:
slli R4 R4
srli R8 R8
addi R11 R11 -1
bnez R11 -8
beqz R15 1
sub R8 R0 R8

* Sum results: R9 = (R1*R5 + R2*R6 + R3*R7 + R4*R8)
add R29 R9 R8
add R9 R9 R29

* ReLU
slti R13 R9 0
beqz R13 1
addi R9 R0 0
*relu_skip:
sw R9 R0 addr1

* --- Row 1 computation ---
addi R7 R0 0
addi R8 R0 0
addi R10 R0 0
addi R11 R0 15

lw R1 R0 data5
lw R2 R0 data6
lw R3 R0 data7
lw R4 R0 data8

* repeat multiplications as above using same structure (mulrst/mac/relu) 
* store result in addr2

* --- Row 2 computation ---
* repeat same, store result in addr3

* --- Row 3 computation ---
* repeat same, store result in addr4

halt

addi R10 R0 0
addi R8 R0 0

* Multiplication 2: R2 * R4 (signed)
addi R16 R0 8000
and R13 R2 R16
and R14 R4 R16
xor R15 R13 R14
beqz R13 1
sub R2 R0 R2
*skip_neg3:
beqz R14 1
sub R4 R0 R4
*skip_neg4:

*mul2_loop:
and R12 R9 R4
beqz R12 2
add R8 R8 R2
addi R10 R10 1
*sll2:
slli R2 R2
srli R4 R4
addi R11 R11 -1
bnez R11 -8

beqz R15 1
sub R8 R0 R8
*skip_sign2:

* Sum results: R7 = (R1 * R3) + (R2 * R4)
add R26 R7 R0
add R27 R8 R0
add R7 R7 R8
add R28 R7 R0
* ReLU: if R7 < 0, set to 0
slti R13 R7 0
beqz R13 1
addi R7 R0 0
*relu1_skip:
sw R7 R0 addr1

* Reset registers
addi R7 R0 0
addi R8 R0 0
addi R10 R0 0
addi R11 R0 15

lw R1 R0 data1
lw R5 R0 data5
lw R2 R0 data2
lw R6 R0 data6

* Multiplication 3: R1 * R5 (signed)
addi R16 R0 8000
and R13 R1 R16
and R14 R5 R16
xor R15 R13 R14
beqz R13 1
sub R1 R0 R1
*skip_neg5:
beqz R14 1
sub R5 R0 R5
*skip_neg6:

*mul3_loop:
and R12 R9 R5
beqz R12 2
add R7 R7 R1
addi R8 R8 1
*sll3:
slli R1 R1
srli R5 R5
addi R10 R10 1
slti R12 R10 16
bnez R12 -9

beqz R15 1
sub R7 R0 R7
*skip_sign3:

* Reset counters
addi R10 R0 0
addi R8 R0 0

* Multiplication 4: R2 * R6 (signed)
addi R16 R0 8000
and R13 R2 R16
and R14 R6 R16
xor R15 R13 R14
beqz R13 1
sub R2 R0 R2
*skip_neg7:
beqz R14 1
sub R6 R0 R6
*skip_neg8:

*mul4_loop:
and R12 R9 R6
beqz R12 2
add R8 R8 R2
addi R10 R10 1
*sll4:
slli R2 R2
srli R6 R6
addi R11 R11 -1
bnez R11 -8

beqz R15 1
sub R8 R0 R8
*skip_sign4:

* Sum results: R7 = (R1 * R5) + (R2 * R6)
add R29 R7 R0
add R30 R8 R0
add R7 R7 R8
add R31 R7 R0
* ReLU: if R7 < 0, set to 0
slti R13 R7 0
beqz R13 1
addi R7 R0 0
*relu2_skip:
sw R7 R0 addr2

halt